// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createActivity = `-- name: CreateActivity :one
INSERT INTO activities (
  id, title, description, venue, start_time, end_time,
  signup_deadline, participant_capacity, volunteer_capacity,
  wheelchair_accessible, sign_language_available, requires_payment,
  status, created_by, created_at
) VALUES (
    gen_random_uuid(), $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, $10, $11,
    $12, $13, $14
)
RETURNING id, title, description, venue, start_time, end_time, signup_deadline, participant_capacity, volunteer_capacity, wheelchair_accessible, sign_language_available, requires_payment, status, created_by, created_at
`

type CreateActivityParams struct {
	Title                 string           `json:"title"`
	Description           interface{}      `json:"description"`
	Venue                 string           `json:"venue"`
	StartTime             pgtype.Timestamp `json:"start_time"`
	EndTime               pgtype.Timestamp `json:"end_time"`
	SignupDeadline        pgtype.Timestamp `json:"signup_deadline"`
	ParticipantCapacity   int32            `json:"participant_capacity"`
	VolunteerCapacity     int32            `json:"volunteer_capacity"`
	WheelchairAccessible  bool             `json:"wheelchair_accessible"`
	SignLanguageAvailable bool             `json:"sign_language_available"`
	RequiresPayment       bool             `json:"requires_payment"`
	Status                string           `json:"status"`
	CreatedBy             int32            `json:"created_by"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, createActivity,
		arg.Title,
		arg.Description,
		arg.Venue,
		arg.StartTime,
		arg.EndTime,
		arg.SignupDeadline,
		arg.ParticipantCapacity,
		arg.VolunteerCapacity,
		arg.WheelchairAccessible,
		arg.SignLanguageAvailable,
		arg.RequiresPayment,
		arg.Status,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Venue,
		&i.StartTime,
		&i.EndTime,
		&i.SignupDeadline,
		&i.ParticipantCapacity,
		&i.VolunteerCapacity,
		&i.WheelchairAccessible,
		&i.SignLanguageAvailable,
		&i.RequiresPayment,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
   id, activity_id, user_id, booked_for_user_id,
   role, is_paid, attendance_status, created_at,
   cancelled_at
) VALUES (
  gen_random_uuid(), $1, $2, $3, $4, $5, $6, NOW(), $7
)
RETURNING id, activity_id, user_id, booked_for_user_id, role, is_paid, attendance_status, created_at, cancelled_at
`

type CreateBookingParams struct {
	ActivityID       int32            `json:"activity_id"`
	UserID           int32            `json:"user_id"`
	BookedForUserID  pgtype.Int4      `json:"booked_for_user_id"`
	Role             string           `json:"role"`
	IsPaid           bool             `json:"is_paid"`
	AttendanceStatus pgtype.Text      `json:"attendance_status"`
	CancelledAt      pgtype.Timestamp `json:"cancelled_at"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.ActivityID,
		arg.UserID,
		arg.BookedForUserID,
		arg.Role,
		arg.IsPaid,
		arg.AttendanceStatus,
		arg.CancelledAt,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ActivityID,
		&i.UserID,
		&i.BookedForUserID,
		&i.Role,
		&i.IsPaid,
		&i.AttendanceStatus,
		&i.CreatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    id,
    user_id,
    refresh_token,
    is_revoked,
    expires_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id, user_id, refresh_token, is_revoked, expires_at, created_at
`

type CreateSessionParams struct {
	ID           string           `json:"id"`
	UserID       int32            `json:"user_id"`
	RefreshToken string           `json:"refresh_token"`
	IsRevoked    bool             `json:"is_revoked"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.RefreshToken,
		arg.IsRevoked,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.IsRevoked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    name,
    phone,
    email,
    role
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, name, phone, email, role, created_at
`

type CreateUserParams struct {
	Name  string `json:"name"`
	Phone string `json:"phone"`
	Email string `json:"email"`
	Role  string `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Phone,
		arg.Email,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const deleteActivityByID = `-- name: DeleteActivityByID :exec
DELETE FROM activities
WHERE id = $1
`

func (q *Queries) DeleteActivityByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteActivityByID, id)
	return err
}

const deleteBookingByID = `-- name: DeleteBookingByID :exec
DELETE FROM bookings
WHERE id = $1
`

func (q *Queries) DeleteBookingByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBookingByID, id)
	return err
}

const deleteSessionsByUserID = `-- name: DeleteSessionsByUserID :exec
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteSessionsByUserID(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteSessionsByUserID, userID)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUserByID, id)
	return err
}

const getActivityByID = `-- name: GetActivityByID :one
SELECT
  id, title, description, venue, start_time, end_time, signup_deadline, participant_capacity, volunteer_capacity, wheelchair_accessible, sign_language_available, requires_payment, status, created_by, created_at
FROM
  activities
WHERE
  id = $1
`

func (q *Queries) GetActivityByID(ctx context.Context, id int32) (Activity, error) {
	row := q.db.QueryRow(ctx, getActivityByID, id)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Venue,
		&i.StartTime,
		&i.EndTime,
		&i.SignupDeadline,
		&i.ParticipantCapacity,
		&i.VolunteerCapacity,
		&i.WheelchairAccessible,
		&i.SignLanguageAvailable,
		&i.RequiresPayment,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, name, phone, email, role, created_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Phone,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT
  id, activity_id, user_id, booked_for_user_id, role, is_paid, attendance_status, created_at, cancelled_at
FROM
  bookings
WHERE
  id = $1
`

func (q *Queries) GetBookingByID(ctx context.Context, id int32) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByID, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ActivityID,
		&i.UserID,
		&i.BookedForUserID,
		&i.Role,
		&i.IsPaid,
		&i.AttendanceStatus,
		&i.CreatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, user_id, refresh_token, is_revoked, expires_at, created_at FROM sessions WHERE id = $1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.IsRevoked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, phone, email, role, created_at FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, phone, email, role, created_at FROM users
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByNameAndPhone = `-- name: GetUserByNameAndPhone :one
SELECT id, name, phone, email, role
FROM users
WHERE LOWER(name) = LOWER($1) AND phone = $2
`

type GetUserByNameAndPhoneParams struct {
	Lower string `json:"lower"`
	Phone string `json:"phone"`
}

type GetUserByNameAndPhoneRow struct {
	ID    int32  `json:"id"`
	Name  string `json:"name"`
	Phone string `json:"phone"`
	Email string `json:"email"`
	Role  string `json:"role"`
}

func (q *Queries) GetUserByNameAndPhone(ctx context.Context, arg GetUserByNameAndPhoneParams) (GetUserByNameAndPhoneRow, error) {
	row := q.db.QueryRow(ctx, getUserByNameAndPhone, arg.Lower, arg.Phone)
	var i GetUserByNameAndPhoneRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, name, phone, email, role, created_at FROM users
WHERE phone = $1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phone string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const listActivities = `-- name: ListActivities :many
SELECT
  id, title, description, venue, start_time, end_time, signup_deadline, participant_capacity, volunteer_capacity, wheelchair_accessible, sign_language_available, requires_payment, status, created_by, created_at 
FROM
  activities
`

func (q *Queries) ListActivities(ctx context.Context) ([]Activity, error) {
	rows, err := q.db.Query(ctx, listActivities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Venue,
			&i.StartTime,
			&i.EndTime,
			&i.SignupDeadline,
			&i.ParticipantCapacity,
			&i.VolunteerCapacity,
			&i.WheelchairAccessible,
			&i.SignLanguageAvailable,
			&i.RequiresPayment,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookings = `-- name: ListBookings :many
SELECT
  id, activity_id, user_id, booked_for_user_id, role, is_paid, attendance_status, created_at, cancelled_at 
FROM
  bookings
`

func (q *Queries) ListBookings(ctx context.Context) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ActivityID,
			&i.UserID,
			&i.BookedForUserID,
			&i.Role,
			&i.IsPaid,
			&i.AttendanceStatus,
			&i.CreatedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByActivityID = `-- name: ListBookingsByActivityID :many
SELECT
  id, activity_id, user_id, booked_for_user_id, role, is_paid, attendance_status, created_at, cancelled_at
FROM
  bookings
WHERE
  activity_id = $1
`

func (q *Queries) ListBookingsByActivityID(ctx context.Context, activityID int32) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByActivityID, activityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ActivityID,
			&i.UserID,
			&i.BookedForUserID,
			&i.Role,
			&i.IsPaid,
			&i.AttendanceStatus,
			&i.CreatedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeSession = `-- name: RevokeSession :exec
UPDATE sessions SET is_revoked = TRUE WHERE id = $1
`

func (q *Queries) RevokeSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, revokeSession, id)
	return err
}

const updateActivityByID = `-- name: UpdateActivityByID :one
UPDATE activities
SET 
  title = $1,
  description = $2,
  venue = $3,
  start_time = $4,
  end_time = $5,
  signup_deadline = $6,
  participant_capacity = $7,
  volunteer_capacity = $8
WHERE id = $9
RETURNING id, title, description, venue, start_time, end_time, signup_deadline, participant_capacity, volunteer_capacity, wheelchair_accessible, sign_language_available, requires_payment, status, created_by, created_at
`

type UpdateActivityByIDParams struct {
	Title               string           `json:"title"`
	Description         interface{}      `json:"description"`
	Venue               string           `json:"venue"`
	StartTime           pgtype.Timestamp `json:"start_time"`
	EndTime             pgtype.Timestamp `json:"end_time"`
	SignupDeadline      pgtype.Timestamp `json:"signup_deadline"`
	ParticipantCapacity int32            `json:"participant_capacity"`
	VolunteerCapacity   int32            `json:"volunteer_capacity"`
	ID                  int32            `json:"id"`
}

func (q *Queries) UpdateActivityByID(ctx context.Context, arg UpdateActivityByIDParams) (Activity, error) {
	row := q.db.QueryRow(ctx, updateActivityByID,
		arg.Title,
		arg.Description,
		arg.Venue,
		arg.StartTime,
		arg.EndTime,
		arg.SignupDeadline,
		arg.ParticipantCapacity,
		arg.VolunteerCapacity,
		arg.ID,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Venue,
		&i.StartTime,
		&i.EndTime,
		&i.SignupDeadline,
		&i.ParticipantCapacity,
		&i.VolunteerCapacity,
		&i.WheelchairAccessible,
		&i.SignLanguageAvailable,
		&i.RequiresPayment,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}
